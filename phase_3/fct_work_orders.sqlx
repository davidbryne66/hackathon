/*
 * FCT_WORK_ORDERS - Work Order Fact Table
 * ============================================================================
 * Description: Manufacturing work orders for production efficiency analysis
 * Grain: One row per work order (routing details aggregated)
 * Source Tables: Production_WorkOrder, Production_WorkOrderRouting
 * Purpose: Track manufacturing efficiency, scrap rates, cost variances
 * ============================================================================
 */

config {
  type: "table",
  schema: "adventure_works",
  name: "fct_work_orders",
  description: "Work order fact table for manufacturing performance analysis. Tracks production efficiency and quality.",
  
  bigquery: {
    partitionBy: "DATE(PARSE_DATE('%Y%m%d', CAST(due_date_key AS STRING)))",
    clusterBy: ["product_key", "location_key"]
  },
  
  dependencies: [
    "dim_date",
    "dim_product",
    "dim_location",
    "dim_scrap_reason"
  ],
  
  tags: ["fact", "manufacturing", "work_orders", "production", "daily"],
  
  assertions: {
    uniqueKey: ["work_order_id"],
    nonNull: ["work_order_id", "product_key", "due_date_key"]
  }
}

-- =============================================================================
-- Work Order Fact Query with Routing Aggregation
-- =============================================================================

WITH source_work_order AS (
  SELECT
    wo.WorkOrderID,
    wo.ProductID,
    wo.OrderQty,
    wo.StockedQty,
    wo.ScrappedQty,
    wo.StartDate,
    wo.EndDate,
    wo.DueDate,
    wo.ScrapReasonID,
    wo.ModifiedDate
  FROM ${ref('Production_WorkOrder')} wo
),

-- Aggregate routing details to work order level
work_order_routing_agg AS (
  SELECT
    wor.WorkOrderID,
    -- Use the first location as the primary location
    MIN(wor.LocationID) AS primary_location_id,
    -- Aggregate costs and hours
    SUM(wor.PlannedCost) AS total_planned_cost,
    SUM(wor.ActualCost) AS total_actual_cost,
    SUM(wor.ActualResourceHrs) AS total_actual_resource_hours,
    -- Calculate earliest start and latest end from routing
    MIN(wor.ScheduledStartDate) AS routing_scheduled_start,
    MAX(wor.ScheduledEndDate) AS routing_scheduled_end,
    MIN(wor.ActualStartDate) AS routing_actual_start,
    MAX(wor.ActualEndDate) AS routing_actual_end
  FROM ${ref('Production_WorkOrderRouting')} wor
  GROUP BY wor.WorkOrderID
),

-- Join work orders with aggregated routing
work_order_base AS (
  SELECT
    wo.WorkOrderID,
    wo.ProductID,
    wo.OrderQty,
    wo.StockedQty,
    wo.ScrappedQty,
    wo.StartDate,
    wo.EndDate,
    wo.DueDate,
    wo.ScrapReasonID,
    wora.primary_location_id,
    wora.total_planned_cost,
    wora.total_actual_cost,
    wora.total_actual_resource_hours
  FROM source_work_order wo
  LEFT JOIN work_order_routing_agg wora
    ON wo.WorkOrderID = wora.WorkOrderID
)

-- =============================================================================
-- Final Work Order Fact Table with Dimension Lookups
-- =============================================================================

SELECT
  -- Surrogate Key
  ROW_NUMBER() OVER (ORDER BY wob.WorkOrderID) AS work_order_key,
  
  -- Dimension Foreign Keys (Surrogate Key Lookups)
  COALESCE(dp.product_key, -1) AS product_key,
  
  -- Date Dimension Foreign Keys (Role-Playing Dimension)
  CAST(FORMAT_DATE('%Y%m%d', wob.StartDate) AS INT64) AS start_date_key,
  CAST(FORMAT_DATE('%Y%m%d', wob.EndDate) AS INT64) AS end_date_key,
  CAST(FORMAT_DATE('%Y%m%d', wob.DueDate) AS INT64) AS due_date_key,
  
  -- Location and Scrap Reason
  COALESCE(dl.location_key, -1) AS location_key,
  COALESCE(dsr.scrap_reason_key, -1) AS scrap_reason_key,
  
  -- Degenerate Dimension
  wob.WorkOrderID AS work_order_id,
  
  -- Additive Measures - Quantity
  wob.OrderQty AS order_quantity,
  wob.StockedQty AS stocked_quantity,
  wob.ScrappedQty AS scrapped_quantity,
  
  -- Additive Measures - Cost & Time
  CAST(COALESCE(wob.total_planned_cost, 0) AS NUMERIC(19,4)) AS planned_cost,
  CAST(COALESCE(wob.total_actual_cost, 0) AS NUMERIC(19,4)) AS actual_cost,
  CAST(COALESCE(wob.total_actual_resource_hours, 0) AS NUMERIC(10,2)) AS actual_resource_hours,
  
  -- Calculated Measures - Cost Variance
  CAST(
    COALESCE(wob.total_actual_cost, 0) - COALESCE(wob.total_planned_cost, 0)
    AS NUMERIC(19,4)
  ) AS cost_variance,
  
  CAST(
    SAFE_DIVIDE(
      COALESCE(wob.total_actual_cost, 0) - COALESCE(wob.total_planned_cost, 0),
      NULLIF(wob.total_planned_cost, 0)
    ) * 100
    AS NUMERIC(10,2)
  ) AS cost_variance_pct,
  
  -- Calculated Measures - Quality Metrics
  CAST(
    SAFE_DIVIDE(wob.ScrappedQty, NULLIF(wob.OrderQty, 0)) * 100
    AS NUMERIC(10,2)
  ) AS scrap_rate_pct,
  
  CAST(
    SAFE_DIVIDE(wob.StockedQty, NULLIF(wob.OrderQty, 0)) * 100
    AS NUMERIC(10,2)
  ) AS yield_rate_pct,
  
  CAST(
    SAFE_DIVIDE(
      COALESCE(wob.total_actual_cost, 0),
      NULLIF(wob.StockedQty, 0)
    )
    AS NUMERIC(19,4)
  ) AS cost_per_unit,
  
  -- Time-based Measures
  DATE_DIFF(wob.EndDate, wob.StartDate, DAY) AS production_days,
  DATE_DIFF(wob.EndDate, wob.DueDate, DAY) AS days_early_late,
  
  -- Efficiency Metrics
  CAST(
    SAFE_DIVIDE(
      wob.OrderQty,
      NULLIF(DATE_DIFF(wob.EndDate, wob.StartDate, DAY), 0)
    )
    AS NUMERIC(10,2)
  ) AS units_per_day,
  
  CAST(
    SAFE_DIVIDE(
      wob.StockedQty,
      NULLIF(wob.total_actual_resource_hours, 0)
    )
    AS NUMERIC(10,2)
  ) AS units_per_hour,
  
  -- Flags
  CASE 
    WHEN wob.EndDate IS NOT NULL THEN TRUE 
    ELSE FALSE 
  END AS is_completed,
  
  CASE 
    WHEN wob.EndDate IS NOT NULL AND wob.EndDate <= wob.DueDate THEN TRUE
    WHEN wob.EndDate IS NULL AND CURRENT_DATE() <= wob.DueDate THEN TRUE
    ELSE FALSE 
  END AS is_on_time,
  
  CASE 
    WHEN wob.ScrappedQty > 0 THEN TRUE 
    ELSE FALSE 
  END AS has_scrap,
  
  CASE 
    WHEN COALESCE(wob.total_actual_cost, 0) > COALESCE(wob.total_planned_cost, 0) THEN TRUE 
    ELSE FALSE 
  END AS is_over_budget,
  
  -- Status Description
  CASE
    WHEN wob.EndDate IS NULL AND CURRENT_DATE() > wob.DueDate THEN 'Overdue'
    WHEN wob.EndDate IS NULL THEN 'In Progress'
    WHEN wob.EndDate <= wob.DueDate THEN 'Completed On Time'
    ELSE 'Completed Late'
  END AS work_order_status,
  
  -- Quality Status
  CASE
    WHEN wob.ScrappedQty = 0 THEN 'Perfect Quality'
    WHEN SAFE_DIVIDE(wob.ScrappedQty, NULLIF(wob.OrderQty, 0)) < 0.05 THEN 'Acceptable Scrap'
    WHEN SAFE_DIVIDE(wob.ScrappedQty, NULLIF(wob.OrderQty, 0)) < 0.10 THEN 'High Scrap'
    ELSE 'Critical Scrap'
  END AS quality_status,
  
  -- Audit Fields
  'Adventure_Works' AS source_system,
  CURRENT_TIMESTAMP() AS created_date,
  CURRENT_TIMESTAMP() AS modified_date

FROM work_order_base wob

-- Join to Dimension Tables to get Surrogate Keys
LEFT JOIN ${ref('dim_product')} dp
  ON wob.ProductID = dp.product_id
  AND dp.is_current = TRUE

LEFT JOIN ${ref('dim_location')} dl
  ON wob.primary_location_id = dl.location_id

LEFT JOIN ${ref('dim_scrap_reason')} dsr
  ON wob.ScrapReasonID = dsr.scrap_reason_id

WHERE wob.DueDate IS NOT NULL
  AND wob.ProductID IS NOT NULL

ORDER BY wob.WorkOrderID

